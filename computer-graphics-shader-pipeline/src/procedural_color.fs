// Set the pixel color to an interesting procedural color generated by mixing
// and filtering Perlin noise of different frequencies.
//
// Uniforms:
uniform mat4 view;
uniform mat4 proj;
uniform float animation_seconds;
uniform bool is_moon;
// Inputs:
in vec3 sphere_fs_in;
in vec3 normal_fs_in;
in vec4 pos_fs_in; 
in vec4 view_pos_fs_in; 
// Outputs:
out vec3 color;

// expects: blinn_phong, perlin_noise
void main()
{
  /////////////////////////////////////////////////////////////////////////////
  // Replace with your code 
  // color = vec3(1,1,1);
	// create a light source and get its coordinate in camera space
    float t = (2.0*M_PI/16.0)*animation_seconds;
    vec4 light = view*vec4(5*cos(t), 6, 5*sin(t), 1);
    vec3 light_loc = light.xyz;
    vec3 view_loc = view_pos_fs_in.xyz;
    float noise_value = 0;
    float total = noise_value;
    float persist = 0.1;
    int octaves = 4;
    float ampl = 0.0002;
    float turbsize, Xlines, Ylines,Zlines, turbPOW;
    Xlines = 1.3;
    Ylines = 0.1;
    Zlines = 0.2;
    turbPOW = 15;
    turbsize = 200;
    int GSIZE = 9;
    for(int i = 0; i < 7; i++){
        noise_value += perlin_noise(sphere_fs_in)*turbsize;
        total += ampl;
        // freq += 2.0f;
        ampl += persist;
        turbsize /= 10.0;
    }
    noise_value /= total;
    noise_value = abs(noise_value);

    vec3 Coord = sphere_fs_in * GSIZE;
    // float yCoord = v * GSIZE;
    float intermediate_tex = Coord.x*Xlines/GSIZE+Coord.y*Ylines/GSIZE+Coord.z
                 * Zlines / GSIZE + turbPOW*noise_value/255;

    float new_texture = 0.6*abs(sin(intermediate_tex*M_PI/2));

    // color = vec3(new_texture, new_texture, new_texture);
    if (is_moon) {
        color = blinn_phong(vec3(0.1, 0.1, 0.1)+vec3(new_texture/20, new_texture/20, new_texture/12), 
            vec3(0.5, 0.5, 0.5)+vec3(new_texture, new_texture, new_texture), vec3(0.6, 0.6, 0.6), 700,
                    normalize(normal_fs_in), normalize(-view_loc), normalize(light_loc-view_loc));
        } else {color = blinn_phong(vec3(0.01, 0.01, 0.1)+vec3(new_texture/20, new_texture/20, new_texture/12), 
                    vec3(0.05, 0.01, 0.4)+vec3(new_texture/2, new_texture/3, new_texture*1.3), vec3(0.6, 0.6, 0.8), 500,
                    normalize(normal_fs_in), normalize(-view_loc), normalize(light_loc-view_loc)); 
    }
  /////////////////////////////////////////////////////////////////////////////
}


